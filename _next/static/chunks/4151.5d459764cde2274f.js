(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4151],{8707:(t,e,r)=>{"use strict";r.r(e),r.d(e,{InferenceSession:()=>A,TRACE:()=>w,TRACE_FUNC_BEGIN:()=>v,TRACE_FUNC_END:()=>E,Tensor:()=>g,env:()=>d,registerBackend:()=>n});let o=new Map,i=[],n=(t,e,r)=>{if(e&&"function"==typeof e.init&&"function"==typeof e.createInferenceSessionHandler){let n=o.get(t);if(void 0===n)o.set(t,{backend:e,priority:r});else if(n.priority>r)return;else if(n.priority===r&&n.backend!==e)throw Error(`cannot register backend "${t}" using priority ${r}`);if(r>=0){let e=i.indexOf(t);-1!==e&&i.splice(e,1);for(let e=0;e<i.length;e++)if(o.get(i[e]).priority<=r)return void i.splice(e,0,t);i.push(t)}return}throw TypeError("not a valid backend")},a=async t=>{let e=o.get(t);if(!e)return"backend not found.";if(e.initialized)return e.backend;{if(e.aborted)return e.error;let r=!!e.initPromise;try{return r||(e.initPromise=e.backend.init(t)),await e.initPromise,e.initialized=!0,e.backend}catch(t){return r||(e.error=`${t}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},s=async t=>{let e,r=t.executionProviders||[],o=r.map(t=>"string"==typeof t?t:t.name),n=0===o.length?i:o,s=[],f=new Set;for(let t of n){let r=await a(t);"string"==typeof r?s.push({name:t,err:r}):(e||(e=r),e===r&&f.add(t))}if(!e)throw Error(`no available backend found. ERR: ${s.map(t=>`[${t.name}] ${t.err}`).join(", ")}`);for(let{name:t,err:e}of s)o.includes(t)&&console.warn(`removing requested execution provider "${t}" from session options because it is not available: ${e}`);let u=r.filter(t=>f.has("string"==typeof t?t:t.name));return[e,new Proxy(t,{get:(t,e)=>"executionProviders"===e?u:Reflect.get(t,e)})]},f="warning",u={wasm:{},webgl:{},webgpu:{},versions:{common:"1.21.0"},set logLevel(value){if(void 0===value)return;if("string"!=typeof value||-1===["verbose","info","warning","error","fatal"].indexOf(value))throw Error(`Unsupported logging level: ${value}`);f=value},get logLevel(){return f}};Object.defineProperty(u,"logLevel",{enumerable:!0});let d=u,l=(t,e)=>{let r,o;if(void 0===t)throw Error("Image buffer must be defined");if(void 0===e.height||void 0===e.width)throw Error("Image height and width must be defined");if("NHWC"===e.tensorLayout)throw Error("NHWC Tensor layout is not supported yet");let{height:i,width:n}=e,a=e.norm??{mean:255,bias:0};r="number"==typeof a.mean?[a.mean,a.mean,a.mean,a.mean]:[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],o="number"==typeof a.bias?[a.bias,a.bias,a.bias,a.bias]:[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];let s=void 0!==e.format?e.format:"RGBA",f=void 0!==e.tensorFormat&&void 0!==e.tensorFormat?e.tensorFormat:"RGB",u=i*n,d=new Float32Array("RGBA"===f?4*u:3*u),l=4,h=0,c=1,p=2,m=3,g=0,w=u,b=2*u,v=-1;"RGB"===s&&(l=3,h=0,c=1,p=2,m=-1),"RGBA"===f?v=3*u:"RBG"===f?(g=0,b=u,w=2*u):"BGR"===f&&(b=0,w=u,g=2*u);for(let e=0;e<u;e++,h+=l,p+=l,c+=l,m+=l)d[g++]=(t[h]+o[0])/r[0],d[w++]=(t[c]+o[1])/r[1],d[b++]=(t[p]+o[2])/r[2],-1!==v&&-1!==m&&(d[v++]=(t[m]+o[3])/r[3]);return"RGBA"===f?new y("float32",d,[1,4,i,n]):new y("float32",d,[1,3,i,n])},h=async(t,e)=>{let r,o="u">typeof HTMLImageElement&&t instanceof HTMLImageElement,i="u">typeof ImageData&&t instanceof ImageData,n="u">typeof ImageBitmap&&t instanceof ImageBitmap,a="string"==typeof t,s=e??{},f=()=>{if("u">typeof document)return document.createElement("canvas");if("u">typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw Error("Canvas is not supported")},u=t=>"u">typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||t instanceof OffscreenCanvas?t.getContext("2d"):null;if(o){let o=f();o.width=t.width,o.height=t.height;let i=u(o);if(null!=i){let o=t.height,n=t.width;if(void 0!==e&&void 0!==e.resizedHeight&&void 0!==e.resizedWidth&&(o=e.resizedHeight,n=e.resizedWidth),void 0!==e){if(s=e,void 0!==e.tensorFormat)throw Error("Image input config format must be RGBA for HTMLImageElement");s.tensorFormat="RGBA",s.height=o,s.width=n}else s.tensorFormat="RGBA",s.height=o,s.width=n;i.drawImage(t,0,0),r=i.getImageData(0,0,n,o).data}else throw Error("Can not access image data")}else if(i){let o,i;if(void 0!==e&&void 0!==e.resizedWidth&&void 0!==e.resizedHeight?(o=e.resizedHeight,i=e.resizedWidth):(o=t.height,i=t.width),void 0!==e&&(s=e),s.format="RGBA",s.height=o,s.width=i,void 0!==e){let e=f();e.width=i,e.height=o;let n=u(e);if(null!=n)n.putImageData(t,0,0),r=n.getImageData(0,0,i,o).data;else throw Error("Can not access image data")}else r=t.data}else if(n){if(void 0===e)throw Error("Please provide image config with format for Imagebitmap");let o=f();o.width=t.width,o.height=t.height;let i=u(o);if(null!=i){let e=t.height,o=t.width;return i.drawImage(t,0,0,o,e),r=i.getImageData(0,0,o,e).data,s.height=e,s.width=o,l(r,s)}throw Error("Can not access image data")}else if(a)return new Promise((e,r)=>{let o=f(),i=u(o);if(!t||!i)return r();let n=new Image;n.crossOrigin="Anonymous",n.src=t,n.onload=()=>{o.width=n.width,o.height=n.height,i.drawImage(n,0,0,o.width,o.height);let t=i.getImageData(0,0,o.width,o.height);s.height=o.height,s.width=o.width,e(l(t.data,s))}});else throw Error("Input data provided is not supported - aborted tensor creation");if(void 0!==r)return l(r,s);throw Error("Input data provided is not supported - aborted tensor creation")},c=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),p=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),m=!1;class y{constructor(t,e,r){let o,i;if((()=>{if(!m){m=!0;let t="u">typeof BigInt64Array&&BigInt64Array.from,e="u">typeof BigUint64Array&&BigUint64Array.from,r=globalThis.Float16Array,o=void 0!==r&&r.from;t&&(c.set("int64",BigInt64Array),p.set(BigInt64Array,"int64")),e&&(c.set("uint64",BigUint64Array),p.set(BigUint64Array,"uint64")),o?(c.set("float16",r),p.set(r,"float16")):c.set("float16",Uint16Array)}})(),"object"==typeof t&&"location"in t)switch(this.dataLocation=t.location,o=t.type,i=t.dims,t.location){case"cpu-pinned":{const e=c.get(o);if(!e)throw TypeError(`unsupported type "${o}" to create tensor from pinned buffer`);if(!(t.data instanceof e))throw TypeError(`buffer should be of type ${e.name}`);this.cpuData=t.data;break}case"texture":if("float32"!==o)throw TypeError(`unsupported type "${o}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break;case"gpu-buffer":if("float32"!==o&&"float16"!==o&&"int32"!==o&&"int64"!==o&&"uint32"!==o&&"uint8"!==o&&"bool"!==o&&"uint4"!==o&&"int4"!==o)throw TypeError(`unsupported type "${o}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break;case"ml-tensor":if("float32"!==o&&"float16"!==o&&"int32"!==o&&"int64"!==o&&"uint32"!==o&&"uint64"!==o&&"int8"!==o&&"uint8"!==o&&"bool"!==o&&"uint4"!==o&&"int4"!==o)throw TypeError(`unsupported type "${o}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break;default:throw Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let n,a;if("string"==typeof t)if(o=t,a=r,"string"===t){if(!Array.isArray(e))throw TypeError("A string tensor's data must be a string array.");n=e}else{const r=c.get(t);if(void 0===r)throw TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(e))if("float16"===t&&r===Uint16Array||"uint4"===t||"int4"===t)throw TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${r.name} as data.`);else n="uint64"===t||"int64"===t?r.from(e,BigInt):r.from(e);else if(e instanceof r)n=e;else if(e instanceof Uint8ClampedArray)if("uint8"===t)n=Uint8Array.from(e);else throw TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if("float16"===t&&e instanceof Uint16Array&&r!==Uint16Array)n=new globalThis.Float16Array(e.buffer,e.byteOffset,e.length);else throw TypeError(`A ${o} tensor's data must be type of ${r}`)}else if(a=e,Array.isArray(t)){if(0===t.length)throw TypeError("Tensor type cannot be inferred from an empty array.");const e=typeof t[0];if("string"===e)o="string",n=t;else if("boolean"===e)o="bool",n=Uint8Array.from(t);else throw TypeError(`Invalid element type of data array: ${e}.`)}else if(t instanceof Uint8ClampedArray)o="uint8",n=Uint8Array.from(t);else{const e=p.get(t.constructor);if(void 0===e)throw TypeError(`Unsupported type for tensor data: ${t.constructor}.`);o=e,n=t}if(void 0===a)a=[n.length];else if(!Array.isArray(a))throw TypeError("A tensor's dims must be a number array");i=a,this.cpuData=n,this.dataLocation="cpu"}const n=(t=>{let e=1;for(let r=0;r<t.length;r++){let o=t[r];if("number"!=typeof o||!Number.isSafeInteger(o))throw TypeError(`dims[${r}] must be an integer, got: ${o}`);if(o<0)throw RangeError(`dims[${r}] must be a non-negative integer, got: ${o}`);e*=o}return e})(i);if(this.cpuData&&n!==this.cpuData.length)if(("uint4"===o||"int4"===o)&&Math.ceil(n/2)===this.cpuData.length);else throw Error(`Tensor's size(${n}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=i,this.size=n}static async fromImage(t,e){return h(t,e)}static fromTexture(t,e){return((t,e)=>{let{width:r,height:o,download:i,dispose:n}=e;return new y({location:"texture",type:"float32",texture:t,dims:[1,o,r,4],download:i,dispose:n})})(t,e)}static fromGpuBuffer(t,e){return((t,e)=>{let{dataType:r,dims:o,download:i,dispose:n}=e;return new y({location:"gpu-buffer",type:r??"float32",gpuBuffer:t,dims:o,download:i,dispose:n})})(t,e)}static fromMLTensor(t,e){return((t,e)=>{let{dataType:r,dims:o,download:i,dispose:n}=e;return new y({location:"ml-tensor",type:r??"float32",mlTensor:t,dims:o,download:i,dispose:n})})(t,e)}static fromPinnedBuffer(t,e,r){return new y({location:"cpu-pinned",type:t,data:e,dims:r??[e.length]})}toDataURL(t){return((t,e)=>{let r="u">typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=t.dims[3],r.height=t.dims[2];let o=r.getContext("2d");if(null!=o){let i,n,a,s;e?.tensorLayout!==void 0&&"NHWC"===e.tensorLayout?(i=t.dims[2],n=t.dims[3]):(i=t.dims[3],n=t.dims[2]);let f=e?.format!==void 0?e.format:"RGB",u=e?.norm;void 0===u||void 0===u.mean?a=[255,255,255,255]:"number"==typeof u.mean?a=[u.mean,u.mean,u.mean,u.mean]:(a=[u.mean[0],u.mean[1],u.mean[2],0],void 0!==u.mean[3]&&(a[3]=u.mean[3])),void 0===u||void 0===u.bias?s=[0,0,0,0]:"number"==typeof u.bias?s=[u.bias,u.bias,u.bias,u.bias]:(s=[u.bias[0],u.bias[1],u.bias[2],0],void 0!==u.bias[3]&&(s[3]=u.bias[3]));let d=n*i,l=0,h=d,c=2*d,p=-1;"RGBA"===f?(l=0,h=d,c=2*d,p=3*d):"RGB"===f?(l=0,h=d,c=2*d):"RBG"===f&&(l=0,c=d,h=2*d);for(let e=0;e<n;e++)for(let r=0;r<i;r++)o.fillStyle="rgba("+(t.data[l++]-s[0])*a[0]+","+(t.data[h++]-s[1])*a[1]+","+(t.data[c++]-s[2])*a[2]+","+(-1===p?255:(t.data[p++]-s[3])*a[3])+")",o.fillRect(r,e,1,1);if("toDataURL"in r)return r.toDataURL();throw Error("toDataURL is not supported")}throw Error("Can not access image data")})(this,t)}toImageData(t){return((t,e)=>{let r,o="u">typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null!=o){let i,n,a,s,f;e?.tensorLayout!==void 0&&"NHWC"===e.tensorLayout?(i=t.dims[2],n=t.dims[1],a=t.dims[3]):(i=t.dims[3],n=t.dims[2],a=t.dims[1]);let u=void 0!==e&&void 0!==e.format?e.format:"RGB",d=e?.norm;void 0===d||void 0===d.mean?s=[255,255,255,255]:"number"==typeof d.mean?s=[d.mean,d.mean,d.mean,d.mean]:(s=[d.mean[0],d.mean[1],d.mean[2],255],void 0!==d.mean[3]&&(s[3]=d.mean[3])),void 0===d||void 0===d.bias?f=[0,0,0,0]:"number"==typeof d.bias?f=[d.bias,d.bias,d.bias,d.bias]:(f=[d.bias[0],d.bias[1],d.bias[2],0],void 0!==d.bias[3]&&(f[3]=d.bias[3]));let l=n*i;if(void 0!==e&&(void 0!==e.format&&4===a&&"RGBA"!==e.format||3===a&&"RGB"!==e.format&&"BGR"!==e.format))throw Error("Tensor format doesn't match input tensor dims");let h=0,c=1,p=2,m=3,y=0,g=l,w=2*l,b=-1;"RGBA"===u?(y=0,g=l,w=2*l,b=3*l):"RGB"===u?(y=0,g=l,w=2*l):"RBG"===u&&(y=0,w=l,g=2*l),r=o.createImageData(i,n);for(let e=0;e<n*i;h+=4,c+=4,p+=4,m+=4,e++)r.data[h]=(t.data[y++]-f[0])*s[0],r.data[c]=(t.data[g++]-f[1])*s[1],r.data[p]=(t.data[w++]-f[2])*s[2],r.data[m]=-1===b?255:(t.data[b++]-f[3])*s[3]}else throw Error("Can not access image data");return r})(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,t&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}default:throw Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw Error("Cannot reshape a tensor that owns GPU resource.");switch(this.location){case"cpu":return new y(this.type,this.data,t);case"cpu-pinned":return new y({location:"cpu-pinned",data:this.data,type:this.type,dims:t});case"texture":return new y({location:"texture",texture:this.texture,type:this.type,dims:t});case"gpu-buffer":return new y({location:"gpu-buffer",gpuBuffer:this.gpuBuffer,type:this.type,dims:t});case"ml-tensor":return new y({location:"ml-tensor",mlTensor:this.mlTensor,type:this.type,dims:t});default:throw Error(`tensorReshape: tensor location ${this.location} is not supported`)}}}let g=y,w=(t,e)=>{(void 0===u.trace?u.wasm.trace:u.trace)&&console.timeStamp(`${t}::ORT::${e}`)},b=(t,e)=>{let r=Error().stack?.split(/\r\n|\r|\n/g)||[],o=!1;for(let i=0;i<r.length;i++){if(o&&!r[i].includes("TRACE_FUNC")){let o=`FUNC_${t}::${r[i].trim().split(" ")[1]}`;e&&(o+=`::${e}`),w("CPU",o);return}r[i].includes("TRACE_FUNC")&&(o=!0)}},v=t=>{(void 0===u.trace?u.wasm.trace:u.trace)&&b("BEGIN",t)},E=t=>{(void 0===u.trace?u.wasm.trace:u.trace)&&b("END",t)};class T{constructor(t){this.handler=t}async run(t,e,r){v();let o={},i={};if("object"!=typeof t||null===t||t instanceof g||Array.isArray(t))throw TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let n=!0;if("object"==typeof e){if(null===e)throw TypeError("Unexpected argument[1]: cannot be null.");if(e instanceof g)throw TypeError("'fetches' cannot be a Tensor");if(Array.isArray(e)){if(0===e.length)throw TypeError("'fetches' cannot be an empty array.");for(let t of(n=!1,e)){if("string"!=typeof t)throw TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(t))throw RangeError(`'fetches' contains invalid output name: ${t}.`);o[t]=null}if("object"==typeof r&&null!==r)i=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else{let t=!1,a=Object.getOwnPropertyNames(e);for(let r of this.outputNames)if(-1!==a.indexOf(r)){let i=e[r];(null===i||i instanceof g)&&(t=!0,n=!1,o[r]=i)}if(t){if("object"==typeof r&&null!==r)i=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else i=e}}else if(void 0!==e)throw TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let e of this.inputNames)if(void 0===t[e])throw Error(`input '${e}' is missing in 'feeds'.`);if(n)for(let t of this.outputNames)o[t]=null;let a=await this.handler.run(t,o,i),s={};for(let t in a)if(Object.hasOwnProperty.call(a,t)){let e=a[t];e instanceof g?s[t]=e:s[t]=new g(e.type,e.data,e.dims)}return E(),s}async release(){return this.handler.dispose()}static async create(t,e,r,o){let i;v();let n={};if("string"==typeof t){if(i=t,"object"==typeof e&&null!==e)n=e;else if(void 0!==e)throw TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(i=t,"object"==typeof e&&null!==e)n=e;else if(void 0!==e)throw TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||"u">typeof SharedArrayBuffer&&t instanceof SharedArrayBuffer){let a=0,s=t.byteLength;if("object"==typeof e&&null!==e)n=e;else if("number"==typeof e){if(!Number.isSafeInteger(a=e))throw RangeError("'byteOffset' must be an integer.");if(a<0||a>=t.byteLength)throw RangeError(`'byteOffset' is out of range [0, ${t.byteLength}).`);if(s=t.byteLength-a,"number"==typeof r){if(!Number.isSafeInteger(s=r))throw RangeError("'byteLength' must be an integer.");if(s<=0||a+s>t.byteLength)throw RangeError(`'byteLength' is out of range (0, ${t.byteLength-a}].`);if("object"==typeof o&&null!==o)n=o;else if(void 0!==o)throw TypeError("'options' must be an object.")}else if(void 0!==r)throw TypeError("'byteLength' must be a number.")}else if(void 0!==e)throw TypeError("'options' must be an object.");i=new Uint8Array(t,a,s)}else throw TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[a,f]=await s(n),u=await a.createInferenceSessionHandler(i,f);return E(),new T(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}let A=T},15861:t=>{var e={229:function(t){var e,r,o,i=t.exports={};function n(){throw Error("setTimeout has not been defined")}function a(){throw Error("clearTimeout has not been defined")}try{e="function"==typeof setTimeout?setTimeout:n}catch(t){e=n}try{r="function"==typeof clearTimeout?clearTimeout:a}catch(t){r=a}function s(t){if(e===setTimeout)return setTimeout(t,0);if((e===n||!e)&&setTimeout)return e=setTimeout,setTimeout(t,0);try{return e(t,0)}catch(r){try{return e.call(null,t,0)}catch(r){return e.call(this,t,0)}}}var f=[],u=!1,d=-1;function l(){u&&o&&(u=!1,o.length?f=o.concat(f):d=-1,f.length&&h())}function h(){if(!u){var t=s(l);u=!0;for(var e=f.length;e;){for(o=f,f=[];++d<e;)o&&o[d].run();d=-1,e=f.length}o=null,u=!1,function(t){if(r===clearTimeout)return clearTimeout(t);if((r===a||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(t);try{r(t)}catch(e){try{return r.call(null,t)}catch(e){return r.call(this,t)}}}(t)}}function c(t,e){this.fun=t,this.array=e}function p(){}i.nextTick=function(t){var e=Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];f.push(new c(t,e)),1!==f.length||u||s(h)},c.prototype.run=function(){this.fun.apply(null,this.array)},i.title="browser",i.browser=!0,i.env={},i.argv=[],i.version="",i.versions={},i.on=p,i.addListener=p,i.once=p,i.off=p,i.removeListener=p,i.removeAllListeners=p,i.emit=p,i.prependListener=p,i.prependOnceListener=p,i.listeners=function(t){return[]},i.binding=function(t){throw Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(t){throw Error("process.chdir is not supported")},i.umask=function(){return 0}}},r={};function o(t){var i=r[t];if(void 0!==i)return i.exports;var n=r[t]={exports:{}},a=!0;try{e[t](n,n.exports,o),a=!1}finally{a&&delete r[t]}return n.exports}o.ab="//",t.exports=o(229)},17394:(t,e,r)=>{"use strict";t.exports=r.p+"static/media/ort.bundle.min.e977de46.mjs"},65364:(t,e,r)=>{"use strict";var o,i;t.exports=(null==(o=r.g.process)?void 0:o.env)&&"object"==typeof(null==(i=r.g.process)?void 0:i.env)?r.g.process:r(15861)},84659:(t,e,r)=>{"use strict";t.exports=r.p+"static/media/ort-wasm-simd-threaded.jsep.03bc89f8.wasm"}}]);